#!/usr/bin/perl

# == SQL 2 Filesystem Abstraction, written by Rene K. Mueller <spiritdude@gmail.com>
#
my $APPNAME = "SQL2FS (sql2fs)";
my $VERSION = "0.0.3";
#
# Description:
#     ./sql2fs <dbname>
#     cd <dbname>
#     ls
#
# History:
# 2020/04/13: 0.0.3: adding mysql support, better usage/help output
# 2020/04/13: 0.0.2: allowing <table>/<col>/<val>#<col> solely, better utf-8 support
# 2020/04/13: 0.0.1: basic functionality works, items return JSON, only PostgreSQL supported

use DBI;
use DBD::Pg;
use DBD::mysql;
use DBD::SQLite;
use Fuse;
use POSIX qw(ENOENT EISDIR EINVAL O_WRONLY);
use JSON;
use Encode;

use strict;
use utf8;
use open qw(:std :utf8);

my $ba2dbi = { pg => "Pg", mysql => "mysql", sqlite => "SQLite" };

my $s2f = { v => 'verbose' };

my $arg = {
   backend => "pg"
};

my $dbh;
my $st_time = time();

my @a;
foreach(@ARGV) {
   if(/^-(\w+)$/) {
      $arg->{$s2f->{$_}}++ foreach(split(/|/,$1));
      next;
   }
   $arg->{$1}++, next if(/^--(\w+)$/);
   $arg->{$1} = $2, next if(/^--(\w+)=(.*)$/);
   push(@a,$_);
}
@ARGV = @a;

if(!defined $ba2dbi->{$arg->{backend}}) {
   print "$APPNAME: ERR: backend '$arg->{backend}' not supported, only ".join(", ",map { "'$_'" } sort keys %$ba2dbi)."\n";
   exit -1;
}

if($arg->{help} || @ARGV!=1) {
   print "USAGE $APPNAME $VERSION: [<options>] <database>
   options:
      --verbose            increase verbosity
        -v or -vvvv           \"       \"
      --backend=<db>       backend db type: ".join(", ",map { "'$_'" } sort keys %$ba2dbi)." (default: $arg->{backend})
      --version            print version and exit

   examples:
      % sql2fs --backend=pg wikidata
      % cd wikidata/
      % ls 
      
      % sql2fs --backend=mysql wordpress
      % cd wordpress/
      % ls
      % killall sql2fs; sudo umount wordpress/

";
   exit 0;
}

if($arg->{version}) {
   print "$APPNAME $VERSION\n";
   exit 0;
}

my $mount = $arg->{db} = shift(@ARGV);    # -- database becomes mount point

mkdir $mount;

die "$APPNAME: $!\n" unless(-d $mount);

$SIG{__DIE__} = sub {
   print "$APPNAME: HINT: sudo umount $mount/\n";
   exit -1;
};

fork && exit;

Fuse::main( 
   mountpoint => $mount, 
   getattr => \&my_getattr,
   getdir => \&my_getdir,
   open => \&my_open, 
   read => \&my_read, 
   release => \&my_close,
   utime => sub { return 0 },
   mountopts => $arg->{allow_other} ? "allow_other":"",
   threaded => 0
);

sub my_open {
   my($path,$mode) = @_;
   print "INF: open($path)\n" if($arg->{verbose});
   $path =~ s#/##;
   my $fh;
   return 0,$fh;
}

sub my_close {
   my($path,$flags,$fh) = @_;
   print "INF: close($path)\n" if($arg->{verbose});
   $path =~ s#/##;
   return 0;
}

sub my_read {
   my($path,$n,$off,$fh) = @_;
   print "INF: read($path,$n,$off)\n" if($arg->{verbose});
   $path =~ s#/##;
   my(@p) = split(/\//,$path);
   if(@p==3) {
      my $f; $f = $1 if($p[2]=~s/#(\w+)$//);
      my $c = sql("select * from $p[0] where $p[1] = ?",$p[2]);
      my $e;
      if($f) {
         $e = encode('utf-8',$c->{$f});
      } else {
         $e = encode('utf-8',to_json($c,{pretty=>1,canonical=>1}));        # -- we need true byte stream
      }
      $e = substr($e,$off,$n);
      return $e;

   } if(@p==4) {     # /<table>/<col>/<val>/<n>
      my $f; $f = $1 if($p[3]=~s/#(\w+)$//);
      my(@c) = sql("select * from $p[0] where $p[1] = ? offset ? limit 1",$p[2],$p[3]);
      return 1 if(@c==0||!$c[0]);
      my $e;
      if($f) {
         $e = encode('utf-8',$c[0]->{$f});
      } else {
         $e = encode('utf-8',to_json($c[0],{pretty=>1,canonical=>1}));        # -- we need true byte stream
      }
      $e = substr($e,$off,$n);
      return $e;
   }
   return -1;
}

sub my_getattr {
   my($path) = @_;
   print "INF: getattr($path)\n" if($arg->{verbose});

   $path =~ s#/##;
   $path = decode('utf-8',$path);

   my(@p) = split(/\//,$path);

   print "INF: path: ",join(",",map { "\"$_\"" } @p),"\n" if($arg->{verbose}>1);

   my($dev, $ino, $mode, $nlink, $uid, $gid, $rdev, $size, $atime, $mtime, $ctime, $blksize, $blocks) = stat(".");

   # ($dev, $ino, $rdev, $blocks, $nlink, $blksize ) = ( 0, 0, 0, 1, 1, 1024 );

   my $context = Fuse::fuse_get_context();
   my $type = 0040;           # -- dir
   my $perm = 0777;
   $size = 0;

   if($p[$#p]=~/^\.{1,2}?$/) {   # . and .. are valid always
      ;
   } elsif(@p<=0) {           # /
      ;
   } elsif(@p==1) {           # /table/
      return ( -ENOENT() ) if($p[0]=~/^\.\w+/);
      #my $c = sql("select * from $p[0]");
      #return ( -ENOENT() ) if(!$c);
      
   } elsif(@p==2) {           # /table/column/
      return ( -ENOENT() ) if($p[0]=~/^\.\w+/);
      #my $c = sql("select * from $p[0]");
      #return ( -ENOENT() ) if(!$c);
      
   } elsif(@p==3) {           # /table/column/value/<v>
      return ( -ENOENT() ) if($p[0]=~/^\.\w+/);
      my $f; $f = $1 if($p[2]=~s/#(\w+)$//);
      my(@c) = sql("select * from $p[0] where $p[1] = ?",$p[2]);
      return ( -ENOENT() ) if(@c==0);
      if(@c==1) {
         my $e;
         if($f) {
            $e = encode('utf-8',$c[0]->{$f});
         } else {
            $e = encode('utf-8',to_json($c[0],{pretty=>1,canonical=>1}));
         }
         $size = length($e);
         $type = 0100;           # -- file
      } else {
         ;                       # -- more values (dir)
      }

   } elsif(@p==4) {           # /table/column/value/<v>/<n>
      return ( -ENOENT() ) if($p[0]=~/^\.\w+/);
      my $f; $f = $1 if($p[3]=~s/#(\w+)$//);
      my(@c) = sql("select * from $p[0] where $p[1] = ? offset ? limit 1",$p[2],$p[3]);
      return ( -ENOENT() ) if(@c==0||!$c[0]);
      my $e;
      if($f) {
         $e = encode('utf-8',$c[0]->{$f});
      } else {
         $e = encode('utf-8',to_json($c[0],{pretty=>1,canonical=>1}));
      }
      $size = length($e);
      $type = 0100;           # -- file
   }

   print "type: $type\n" if($arg->{verbose}>2);
   $atime = time();
   $mtime = $ctime = $st_time;
   $mode = ($type << 9) + $perm;
   $uid = $context->{uid};
   $gid = $context->{gid};
   print "valid file: ",
      join(",", $dev, $ino, $mode, $nlink, $uid, $gid, $rdev, $size, $atime, $mtime, $ctime, $blksize, $blocks ),"\n" if($arg->{verbose}>3);
   return ( $dev, $ino, $mode, $nlink, $uid, $gid, $rdev, $size, $atime, $mtime, $ctime, $blksize, $blocks );
}

sub my_getdir {
   my($path) = @_;
   print "INF: getdir($path)\n" if($arg->{verbose});
   $path =~ s#/##;
   
   my @d;

   push(@d,'.','..');      # -- must be there at all times - we are in UNIX world

   my(@p) = split(/\//,$path);

   if(@p==0) {     # /
      if($arg->{backend}eq'mysql') {
         @d = sql("show tables");
         @d = map { $_->{"Tables_in_$arg->{db}"} } @d;
      } else {
         @d = sql("select * from pg_catalog.pg_tables where schemaname != 'pg_catalog' and schemaname != 'information_schema'");
         @d = map { $_->{tablename} } @d;
      }
      print to_json(\@d,{pretty=>1,canonical=>1}) if($arg->{verbose}>3);
      @d = sort map { encode('utf-8',$_) } @d;

   } elsif(@p==1) {          
      if($arg->{backend}eq'mysql') {
         @d = sql("show columns from $p[0]");
         @d = map { $_->{Field} } @d;
      } else {
         @d = sql("select * from information_schema.columns where table_name = ?",$p[0]);
         @d = map { $_->{column_name} } @d;
      }
      @d = sort map { encode('utf-8',$_) } @d;
      print to_json(\@d,{pretty=>1,canonical=>1}) if($arg->{verbose}>3);
      #push(@d,sort keys %{$d[0]});

   } elsif(@p==2) {     # /<table>/<col>/<val>
      @d = sql("select distinct $p[1] from $p[0]");
      #@d = sql("select distinct ? from ?",$p[1],$p[0]);    # -- would be safe ... but doesn't work ... (SQL sucks)
      @d = sort map { encode('utf-8',$_->{$p[1]}) } @d;
      print to_json(\@d,{pretty=>1,canonical=>1}) if($arg->{verbose}>3);

   } elsif(@p==3) {     # /<table>/<col>/<val>/<id>
      @d = sql("select * from $p[0] where $p[1] = ?",$p[2]);
      my $n = 0;
      @d = map { $n++; } @d;
      print to_json(\@d,{pretty=>1,canonical=>1}) if($arg->{verbose}>3);
   }
   push(@d,0);
   return @d;
}

sub sql {
   my($sql) = shift;
   my @a = @_;
   my $opts = ref(@a[$#a])eq'HASH'?pop(@a):{};

   unless($dbh) {
      $dbh = DBI->connect("dbi:$ba2dbi->{$arg->{backend}}:dbname=".$arg->{db});
   }

   print "INF: sql \"$sql\" ".join(" ",map {"\"$_\""} @a)."\n" if($arg->{verbose}>1);
   my $sth = $dbh->prepare($sql);
   my $s = $sth->execute(@a);
   my @r;

   print STDERR "SQL ERR ".$dbh->errstr()."\n" if($dbh->errstr());
   if(defined $opts->{results} && $opts->{results}==0) {
      $sth->{finish};
      return;
   } else {
      while(my $e = $sth->fetchrow_hashref()) {
         if(ref($opts->{callback})eq'CODE') {
            &{$opts->{callback}}($e);
         } else {
            push(@r,$e);
         }
      }
   }
   print "INF:   ".scalar @r." results, returning ".(wantarray ? "array":"scalar")."\n" if($arg->{verbose}>1);
   $sth->{finish};
   return wantarray ? @r : $r[0];
}

